from collections import deque

# Function to check if the state is the goal
def is_goal(state, goal):
    return state == goal

# Function to find the possible moves (neighbors)
def get_neighbors(state):
    neighbors = []
    idx = state.index(0)  # position of blank
    row, col = divmod(idx, 3)

    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right
    for dr, dc in moves:
        new_row, new_col = row + dr, col + dc
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_idx = new_row * 3 + new_col
            new_state = state[:]
            # Swap blank with new position
            new_state[idx], new_state[new_idx] = new_state[new_idx], new_state[idx]
            neighbors.append(new_state)
    return neighbors

# BFS algorithm
def bfs(start, goal):
    visited = set()
    queue = deque([(start, [])])  # (current_state, path)

    while queue:
        state, path = queue.popleft()
        if tuple(state) in visited:
            continue
        visited.add(tuple(state))

        if is_goal(state, goal):
            return path + [state]

        for neighbor in get_neighbors(state):
            queue.append((neighbor, path + [state]))
    return None

# Example run
start = [1, 2, 3,
         4, 0, 5,
         6, 7, 8]

goal = [1, 2, 3,
        4, 5, 6,
        7, 8, 0]

solution = bfs(start, goal)


Name=input("Enter Student Name:")
RegNo=int(input("Enter Reg No:"))

if solution:
    print("Steps to solve 8-Puzzle:")
    for step in solution:
        for i in range(0, 9, 3):
            print(step[i:i+3])
        print()
else:
    print("No solution found.")
